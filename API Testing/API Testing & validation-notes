API Testing Checklist:

1. Verify correct HTTP status code. For example, creating a resource should return 201 CREATED and unpermitted requests should return 403 FORBIDDEN, etc.
2. Verify response payload. Check valid JSON body and correct field names, types, and values — including in error responses.
3. Verify response headers. HTTP server headers have implications on both security and performance.
4. Verify correct application state. This is optional and applies mainly to manual testing, or when a UI or another interface can be easily inspected.  
5. Verify basic performance sanity. If an operation was completed successfully but took an unreasonable amount of time, the test fails.

Basic positive tests (happy paths)
Extended positive testing with optional parameters
Negative testing with valid input
Negative testing with invalid input
Destructive testing
Security, authorization, and permission tests

Verify that HTTP headers are as expected, including
content-type,
connection,
cache-control,
expires,
access-control-allow-origin,
keep-alive, HSTS, and other standard header fields – according to spec.

Verify that information is NOT leaked via headers (e.g.
X-Powered-By
header is not sent to user). 

Negative testing – valid input

Execute API calls with valid input that attempts illegal operations. i.e.:
– Attempting to create a resource with a name that already exists (e.g., user configuration with the same name)
– Attempting to delete a resource that doesn’t
exist (e.g., user configuration with no such ID)
– Attempting to update a resource with illegal valid data (e.g., rename a configuration to an existing name)
– Attempting illegal operation (e.g., delete a user configuration without permission.)

Negative testing – invalid input
Execute API calls with invalid input, e.g.:

– Missing or invalid authorization token
– Missing required parameters
– Invalid value for endpoint parameters, e.g.:
– Invalid UUID in path or query parameters
– Payload with invalid model (violates schema)
– Payload with incomplete model (missing fields or required nested entities)
– Invalid values in nested entity fields
– Invalid values in HTTP headers
– Unsupported methods for endpoints 

Destructive testing
Intentionally attempt to fail the API to check its robustness:
Malformed content in request
Wrong content-type in payload
Content with wrong structure
Overflow parameter values. E.g.:
– Attempt to create a user configuration with a title longer than 200 characters
– Attempt to GET a user with invalid UUID 
which is 1000 characters long
– Overflow payload – huge JSON in request body

Boundary value testing 
Empty payloads
Empty sub-objects in payload
Illegal characters in parameters or payload 
Using incorrect HTTP headers (e.g. Content-Type)
Small concurrency tests – concurrent API calls that write to the same resources (DELETE + PATCH, etc.)

Other exploratory testing

Performance
Check API response time, latency, TTFB/TTLB in various scenarios (in isolation and under load)

Load Tests (positive), Stress Tests (negative)
Find capacity limit points and ensure the system performs as expected under load, and fails gracefully under stress 

Usability Tests 
For public APIs: a manual “Product”-level test going through the entire developer journey from documentation, login, authentication, code examples, etc. to ensure the usability of the API for users without prior knowledge of our system.